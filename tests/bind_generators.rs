// Tests for Rust, PyTorch, CMake, and C++ binding generation.

fn scale_json() -> &'static str {
    r#"{
  "library": "kernel.so",
  "exports": [
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "alpha", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#
}

fn dot_json() -> &'static str {
    r#"{
  "library": "dot.so",
  "exports": [
    {
      "name": "dot",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "n", "type": "i32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#
}

fn multi_json() -> &'static str {
    r#"{
  "library": "multi.so",
  "exports": [
    {
      "name": "add",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "out", "type": "*mut f32"}, {"name": "n", "type": "i32"}],
      "return_type": null
    },
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "factor", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#
}

// --- Rust generation tests ---

#[test]
fn test_rust_generation_basic() {
    let rs = ea_compiler::bind_rust::generate(scale_json(), "kernel").unwrap();

    assert!(rs.contains("//! kernel — generated by ea bind"));
    assert!(rs.contains("#[link(name = \"kernel\")]"));
    assert!(rs.contains("mod ffi {"));
    assert!(rs.contains("extern \"C\" {"));
    // FFI signature with raw pointers
    assert!(rs.contains("data: *mut f32"));
    assert!(rs.contains("len: i32"));
    assert!(rs.contains("alpha: f32"));
    // Safe wrapper with slices
    assert!(rs.contains("data: &mut [f32]"));
    // Length collapsed — not in safe signature
    assert!(rs.contains("data.len() as i32"));
    assert!(rs.contains("data.as_mut_ptr()"));
}

#[test]
fn test_rust_generation_return_type() {
    let rs = ea_compiler::bind_rust::generate(dot_json(), "dot").unwrap();

    assert!(rs.contains("-> f32"));
    assert!(rs.contains("a: *const f32"));
    assert!(rs.contains("b: *const f32"));
    // Safe wrapper
    assert!(rs.contains("a: &[f32]"));
    assert!(rs.contains("b: &[f32]"));
    assert!(rs.contains("a.as_ptr()"));
    // n collapsed from last preceding pointer (b)
    assert!(rs.contains("b.len() as i32"));
}

#[test]
fn test_rust_generation_multiple_functions() {
    let rs = ea_compiler::bind_rust::generate(multi_json(), "multi").unwrap();

    assert!(rs.contains("pub fn add("));
    assert!(rs.contains("pub fn scale("));
    assert!(rs.contains("ffi::add("));
    assert!(rs.contains("ffi::scale("));
}

#[test]
fn test_roundtrip_source_to_rust() {
    let source = r#"
        export func fma_kernel(a: *restrict f32, b: *restrict f32, c: *restrict f32, out: *mut f32, len: i32) {
            let mut i: i32 = 0
            while i < len {
                out[i] = a[i] * b[i] + c[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "fma.so");

    let rs = ea_compiler::bind_rust::generate(&json, "fma").unwrap();

    assert!(rs.contains("extern \"C\""));
    assert!(rs.contains("pub fn fma_kernel("));
    assert!(rs.contains("a: &[f32]"));
    assert!(rs.contains("out: &mut [f32]"));
    // len collapsed
    assert!(rs.contains(".len() as i32"));
}

// --- PyTorch generation tests ---

#[test]
fn test_pytorch_generation_basic() {
    let pt = ea_compiler::bind_pytorch::generate(scale_json(), "kernel").unwrap();

    assert!(pt.contains("\"\"\"kernel — generated by ea bind (PyTorch)\"\"\""));
    assert!(pt.contains("import torch as _torch"));
    assert!(pt.contains("_lib = _ct.CDLL("));
    assert!(pt.contains("torch.autograd.Function"));
    assert!(pt.contains("def forward("));
    assert!(pt.contains("data_ptr()"));
    assert!(pt.contains("contiguous().float()"));
    assert!(pt.contains(".numel()"));
    assert!(pt.contains("def backward("));
    assert!(pt.contains("NotImplementedError"));
    // Wrapper function
    assert!(pt.contains("def scale("));
}

#[test]
fn test_pytorch_generation_return_type() {
    let pt = ea_compiler::bind_pytorch::generate(dot_json(), "dot").unwrap();

    assert!(pt.contains("_lib.dot.restype = _ct.c_float"));
    assert!(pt.contains("class _Dot(_torch.autograd.Function)"));
    assert!(pt.contains("def dot("));
}

#[test]
fn test_pytorch_generation_multiple_functions() {
    let pt = ea_compiler::bind_pytorch::generate(multi_json(), "multi").unwrap();

    assert!(pt.contains("class _Add("));
    assert!(pt.contains("class _Scale("));
    assert!(pt.contains("def add("));
    assert!(pt.contains("def scale("));
}

#[test]
fn test_roundtrip_source_to_pytorch() {
    let source = r#"
        export func scale(data: *mut f32, len: i32, alpha: f32) {
            let mut i: i32 = 0
            while i < len {
                data[i] = data[i] * alpha
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "scale.so");

    let pt = ea_compiler::bind_pytorch::generate(&json, "scale").unwrap();

    assert!(pt.contains("torch.autograd.Function"));
    assert!(pt.contains("data_ptr()"));
    assert!(pt.contains("contiguous().float()"));
}

// --- CMake generation tests ---

#[test]
fn test_cmake_generation() {
    let (cmakelists, ea_cmake) = ea_compiler::bind_cmake::generate("kernel");

    // CMakeLists.txt
    assert!(cmakelists.contains("cmake_minimum_required(VERSION 3.16)"));
    assert!(cmakelists.contains("project(kernel C)"));
    assert!(cmakelists.contains("include(EaCompiler.cmake)"));
    assert!(cmakelists.contains("add_ea_kernel(kernel kernel.ea)"));
    assert!(cmakelists.contains("target_link_libraries(app kernel m)"));

    // EaCompiler.cmake
    assert!(ea_cmake.contains("find_program(EA_COMPILER ea REQUIRED)"));
    assert!(ea_cmake.contains("function(add_ea_kernel target source)"));
    assert!(ea_cmake.contains("add_custom_command("));
    assert!(ea_cmake.contains("add_library(${target} STATIC"));
}

#[test]
fn test_cmake_different_stems() {
    let (cmakelists, _) = ea_compiler::bind_cmake::generate("particle_sim");

    assert!(cmakelists.contains("project(particle_sim C)"));
    assert!(cmakelists.contains("add_ea_kernel(particle_sim particle_sim.ea)"));
}

// --- C++ generation tests ---

#[test]
fn test_cpp_generation_basic() {
    let hpp = ea_compiler::bind_cpp::generate(scale_json(), "kernel").unwrap();

    assert!(hpp.contains("#pragma once"));
    assert!(hpp.contains("#include <cstdint>"));
    assert!(hpp.contains("#include <span>"));
    assert!(hpp.contains("namespace ea {"));
    assert!(hpp.contains("extern \"C\" {"));
    // Raw C declaration
    assert!(hpp.contains("void scale(float* data, int32_t len, float alpha)"));
    // Span overload
    assert!(hpp.contains("std::span<float> data"));
    assert!(hpp.contains("data.data()"));
    assert!(hpp.contains("static_cast<int32_t>(data.size())"));
    assert!(hpp.contains("} // namespace ea"));
}

#[test]
fn test_cpp_generation_return_type() {
    let hpp = ea_compiler::bind_cpp::generate(dot_json(), "kernel").unwrap();

    assert!(hpp.contains("float dot(const float* a, const float* b, int32_t n)"));
    // Span overload
    assert!(hpp.contains("std::span<const float> a"));
    assert!(hpp.contains("std::span<const float> b"));
    assert!(hpp.contains("return dot("));
}

#[test]
fn test_cpp_generation_multiple_functions() {
    let hpp = ea_compiler::bind_cpp::generate(multi_json(), "multi").unwrap();

    assert!(hpp.contains("void add("));
    assert!(hpp.contains("void scale("));
    // Both have span overloads
    assert!(hpp.contains("inline void add("));
    assert!(hpp.contains("inline void scale("));
}

#[test]
fn test_roundtrip_source_to_cpp() {
    let source = r#"
        export func dot(a: *f32, b: *f32, n: i32) -> f32 {
            let mut sum: f32 = 0.0
            let mut i: i32 = 0
            while i < n {
                sum = sum + a[i] * b[i]
                i = i + 1
            }
            return sum
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "dot.so");

    let hpp = ea_compiler::bind_cpp::generate(&json, "dot").unwrap();

    assert!(hpp.contains("namespace ea {"));
    assert!(hpp.contains("std::span<const float>"));
    assert!(hpp.contains("extern \"C\""));
    assert!(hpp.contains(".size()"));
}
