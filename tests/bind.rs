/// Tests for JSON metadata emission and binding generation (Python, Rust, PyTorch, CMake, C++).

// --- JSON metadata tests (no LLVM needed) ---

#[test]
fn test_json_metadata_exports() {
    let source = r#"
        export func scale(data: *mut f32, len: i32, alpha: f32) {
            let mut i: i32 = 0
            while i < len {
                data[i] = data[i] * alpha
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "scale.so");

    assert!(json.contains("\"library\": \"scale.so\""));
    assert!(json.contains("\"name\": \"scale\""));
    assert!(json.contains("\"name\": \"data\", \"type\": \"*mut f32\""));
    assert!(json.contains("\"name\": \"len\", \"type\": \"i32\""));
    assert!(json.contains("\"name\": \"alpha\", \"type\": \"f32\""));
    assert!(json.contains("\"return_type\": null"));
}

#[test]
fn test_json_metadata_return_type() {
    let source = r#"
        export func dot(a: *f32, b: *f32, n: i32) -> f32 {
            let mut sum: f32 = 0.0
            let mut i: i32 = 0
            while i < n {
                sum = sum + a[i] * b[i]
                i = i + 1
            }
            return sum
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "dot.so");

    assert!(json.contains("\"name\": \"dot\""));
    assert!(json.contains("\"return_type\": \"f32\""));
}

#[test]
fn test_json_metadata_struct() {
    let source = r#"
        struct Particle {
            x: f32,
            y: f32,
        }

        export func update(p: *mut Particle, n: i32) {
            let mut i: i32 = 0
            while i < n {
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "particle.so");

    assert!(json.contains("\"name\": \"Particle\""));
    assert!(json.contains("\"name\": \"x\", \"type\": \"f32\""));
    assert!(json.contains("\"name\": \"y\", \"type\": \"f32\""));
    assert!(json.contains("\"name\": \"update\""));
}

#[test]
fn test_json_metadata_multiple_exports() {
    let source = r#"
        export func add(a: *f32, b: *f32, out: *mut f32, n: i32) {
            let mut i: i32 = 0
            while i < n {
                out[i] = a[i] + b[i]
                i = i + 1
            }
        }

        func helper(x: i32) -> i32 {
            return x * 2
        }

        export func scale(data: *mut f32, n: i32, factor: f32) {
            let mut i: i32 = 0
            while i < n {
                data[i] = data[i] * factor
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "math.so");

    assert!(json.contains("\"name\": \"add\""));
    assert!(json.contains("\"name\": \"scale\""));
    // helper is not exported — should not appear
    assert!(!json.contains("\"name\": \"helper\""));
}

#[test]
fn test_json_metadata_restrict_pointer() {
    let source = r#"
        export func copy(src: *restrict f32, dst: *mut f32, n: i32) {
            let mut i: i32 = 0
            while i < n {
                dst[i] = src[i]
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "copy.so");

    assert!(json.contains("\"type\": \"*restrict f32\""));
    assert!(json.contains("\"type\": \"*mut f32\""));
}

// --- Python generation tests ---

#[test]
fn test_python_generation_basic() {
    let json = r#"{
  "library": "kernel.so",
  "exports": [
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "alpha", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "kernel").unwrap();

    assert!(py.contains("\"\"\"kernel — generated by ea bind\"\"\""));
    assert!(py.contains("import ctypes as _ct"));
    assert!(py.contains("import numpy as _np"));
    assert!(py.contains("_lib = _ct.CDLL("));
    assert!(py.contains("kernel.so"));
    assert!(py.contains("_lib.scale.argtypes = ["));
    assert!(py.contains("_ct.POINTER(_ct.c_float)"));
    assert!(py.contains("_ct.c_int32"));
    assert!(py.contains("_ct.c_float"));
    assert!(py.contains("_lib.scale.restype = None"));
    // len should be collapsed — not in Python signature
    assert!(py.contains("def scale(data: _np.ndarray, alpha: float):"));
    // dtype check
    assert!(py.contains("if data.dtype != _np.float32:"));
    assert!(py.contains("raise TypeError(\"data: expected float32\")"));
    // Auto-fill len from data.size
    assert!(py.contains("data.size"));
}

#[test]
fn test_python_generation_return_type() {
    let json = r#"{
  "library": "dot.so",
  "exports": [
    {
      "name": "dot",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "n", "type": "i32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "dot").unwrap();

    assert!(py.contains("_lib.dot.restype = _ct.c_float"));
    assert!(py.contains("-> float:"));
    assert!(py.contains("_result = _lib.dot("));
    assert!(py.contains("return float(_result)"));
}

#[test]
fn test_python_generation_no_collapse_without_pointer() {
    let json = r#"{
  "library": "test.so",
  "exports": [
    {
      "name": "compute",
      "args": [{"name": "n", "type": "i32"}, {"name": "x", "type": "f32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "test").unwrap();

    // n should NOT be collapsed (no preceding pointer)
    assert!(py.contains("def compute(n: int, x: float)"));
}

#[test]
fn test_python_generation_multiple_functions() {
    let json = r#"{
  "library": "multi.so",
  "exports": [
    {
      "name": "add",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "out", "type": "*mut f32"}, {"name": "n", "type": "i32"}],
      "return_type": null
    },
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "factor", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "multi").unwrap();

    assert!(py.contains("def add("));
    assert!(py.contains("def scale("));
    assert!(py.contains("_lib.add.argtypes"));
    assert!(py.contains("_lib.scale.argtypes"));
}

// --- Round-trip test: source → parse → JSON → Python ---

#[test]
fn test_roundtrip_source_to_python() {
    let source = r#"
        export func fma_kernel(a: *restrict f32, b: *restrict f32, c: *restrict f32, out: *mut f32, len: i32) {
            let mut i: i32 = 0
            while i < len {
                out[i] = a[i] * b[i] + c[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "fma.so");

    let py = ea_compiler::bind_python::generate(&json, "fma").unwrap();

    // Verify structural correctness
    assert!(py.contains("\"\"\"fma — generated by ea bind\"\"\""));
    assert!(py.contains("def fma_kernel("));
    assert!(py.contains("a: _np.ndarray"));
    assert!(py.contains("b: _np.ndarray"));
    assert!(py.contains("c: _np.ndarray"));
    assert!(py.contains("out: _np.ndarray"));
    // len should be collapsed
    assert!(!py.contains("len: int"));
    assert!(py.contains(".size"));
    // dtype checks for all pointer args
    assert!(py.contains("if a.dtype != _np.float32:"));
    assert!(py.contains("if b.dtype != _np.float32:"));
    assert!(py.contains("if c.dtype != _np.float32:"));
    assert!(py.contains("if out.dtype != _np.float32:"));
}

#[test]
fn test_roundtrip_integer_types() {
    let source = r#"
        export func process_bytes(input: *u8, output: *mut u8, count: i32) {
            let mut i: i32 = 0
            while i < count {
                output[i] = input[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "bytes.so");

    let py = ea_compiler::bind_python::generate(&json, "bytes").unwrap();

    assert!(py.contains("_ct.POINTER(_ct.c_uint8)"));
    assert!(py.contains("_np.uint8"));
    // count should be collapsed
    assert!(py.contains("def process_bytes(input: _np.ndarray, output: _np.ndarray):"));
}

// --- Rust generation tests ---

fn scale_json() -> &'static str {
    r#"{
  "library": "kernel.so",
  "exports": [
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "alpha", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#
}

fn dot_json() -> &'static str {
    r#"{
  "library": "dot.so",
  "exports": [
    {
      "name": "dot",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "n", "type": "i32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#
}

fn multi_json() -> &'static str {
    r#"{
  "library": "multi.so",
  "exports": [
    {
      "name": "add",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "out", "type": "*mut f32"}, {"name": "n", "type": "i32"}],
      "return_type": null
    },
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "factor", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#
}

#[test]
fn test_rust_generation_basic() {
    let rs = ea_compiler::bind_rust::generate(scale_json(), "kernel").unwrap();

    assert!(rs.contains("//! kernel — generated by ea bind"));
    assert!(rs.contains("#[link(name = \"kernel\")]"));
    assert!(rs.contains("mod ffi {"));
    assert!(rs.contains("extern \"C\" {"));
    // FFI signature with raw pointers
    assert!(rs.contains("data: *mut f32"));
    assert!(rs.contains("len: i32"));
    assert!(rs.contains("alpha: f32"));
    // Safe wrapper with slices
    assert!(rs.contains("data: &mut [f32]"));
    // Length collapsed — not in safe signature
    assert!(rs.contains("data.len() as i32"));
    assert!(rs.contains("data.as_mut_ptr()"));
}

#[test]
fn test_rust_generation_return_type() {
    let rs = ea_compiler::bind_rust::generate(dot_json(), "dot").unwrap();

    assert!(rs.contains("-> f32"));
    assert!(rs.contains("a: *const f32"));
    assert!(rs.contains("b: *const f32"));
    // Safe wrapper
    assert!(rs.contains("a: &[f32]"));
    assert!(rs.contains("b: &[f32]"));
    assert!(rs.contains("a.as_ptr()"));
    // n collapsed from last preceding pointer (b)
    assert!(rs.contains("b.len() as i32"));
}

#[test]
fn test_rust_generation_multiple_functions() {
    let rs = ea_compiler::bind_rust::generate(multi_json(), "multi").unwrap();

    assert!(rs.contains("pub fn add("));
    assert!(rs.contains("pub fn scale("));
    assert!(rs.contains("ffi::add("));
    assert!(rs.contains("ffi::scale("));
}

#[test]
fn test_roundtrip_source_to_rust() {
    let source = r#"
        export func fma_kernel(a: *restrict f32, b: *restrict f32, c: *restrict f32, out: *mut f32, len: i32) {
            let mut i: i32 = 0
            while i < len {
                out[i] = a[i] * b[i] + c[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "fma.so");

    let rs = ea_compiler::bind_rust::generate(&json, "fma").unwrap();

    assert!(rs.contains("extern \"C\""));
    assert!(rs.contains("pub fn fma_kernel("));
    assert!(rs.contains("a: &[f32]"));
    assert!(rs.contains("out: &mut [f32]"));
    // len collapsed
    assert!(rs.contains(".len() as i32"));
}

// --- PyTorch generation tests ---

#[test]
fn test_pytorch_generation_basic() {
    let pt = ea_compiler::bind_pytorch::generate(scale_json(), "kernel").unwrap();

    assert!(pt.contains("\"\"\"kernel — generated by ea bind (PyTorch)\"\"\""));
    assert!(pt.contains("import torch as _torch"));
    assert!(pt.contains("_lib = _ct.CDLL("));
    assert!(pt.contains("torch.autograd.Function"));
    assert!(pt.contains("def forward("));
    assert!(pt.contains("data_ptr()"));
    assert!(pt.contains("contiguous().float()"));
    assert!(pt.contains(".numel()"));
    assert!(pt.contains("def backward("));
    assert!(pt.contains("NotImplementedError"));
    // Wrapper function
    assert!(pt.contains("def scale("));
}

#[test]
fn test_pytorch_generation_return_type() {
    let pt = ea_compiler::bind_pytorch::generate(dot_json(), "dot").unwrap();

    assert!(pt.contains("_lib.dot.restype = _ct.c_float"));
    assert!(pt.contains("class _Dot(_torch.autograd.Function)"));
    assert!(pt.contains("def dot("));
}

#[test]
fn test_pytorch_generation_multiple_functions() {
    let pt = ea_compiler::bind_pytorch::generate(multi_json(), "multi").unwrap();

    assert!(pt.contains("class _Add("));
    assert!(pt.contains("class _Scale("));
    assert!(pt.contains("def add("));
    assert!(pt.contains("def scale("));
}

#[test]
fn test_roundtrip_source_to_pytorch() {
    let source = r#"
        export func scale(data: *mut f32, len: i32, alpha: f32) {
            let mut i: i32 = 0
            while i < len {
                data[i] = data[i] * alpha
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "scale.so");

    let pt = ea_compiler::bind_pytorch::generate(&json, "scale").unwrap();

    assert!(pt.contains("torch.autograd.Function"));
    assert!(pt.contains("data_ptr()"));
    assert!(pt.contains("contiguous().float()"));
}

// --- CMake generation tests ---

#[test]
fn test_cmake_generation() {
    let (cmakelists, ea_cmake) = ea_compiler::bind_cmake::generate("kernel");

    // CMakeLists.txt
    assert!(cmakelists.contains("cmake_minimum_required(VERSION 3.16)"));
    assert!(cmakelists.contains("project(kernel C)"));
    assert!(cmakelists.contains("include(EaCompiler.cmake)"));
    assert!(cmakelists.contains("add_ea_kernel(kernel kernel.ea)"));
    assert!(cmakelists.contains("target_link_libraries(app kernel m)"));

    // EaCompiler.cmake
    assert!(ea_cmake.contains("find_program(EA_COMPILER ea REQUIRED)"));
    assert!(ea_cmake.contains("function(add_ea_kernel target source)"));
    assert!(ea_cmake.contains("add_custom_command("));
    assert!(ea_cmake.contains("add_library(${target} STATIC"));
}

#[test]
fn test_cmake_different_stems() {
    let (cmakelists, _) = ea_compiler::bind_cmake::generate("particle_sim");

    assert!(cmakelists.contains("project(particle_sim C)"));
    assert!(cmakelists.contains("add_ea_kernel(particle_sim particle_sim.ea)"));
}

// --- C++ generation tests ---

#[test]
fn test_cpp_generation_basic() {
    let hpp = ea_compiler::bind_cpp::generate(scale_json(), "kernel").unwrap();

    assert!(hpp.contains("#pragma once"));
    assert!(hpp.contains("#include <cstdint>"));
    assert!(hpp.contains("#include <span>"));
    assert!(hpp.contains("namespace ea {"));
    assert!(hpp.contains("extern \"C\" {"));
    // Raw C declaration
    assert!(hpp.contains("void scale(float* data, int32_t len, float alpha)"));
    // Span overload
    assert!(hpp.contains("std::span<float> data"));
    assert!(hpp.contains("data.data()"));
    assert!(hpp.contains("static_cast<int32_t>(data.size())"));
    assert!(hpp.contains("} // namespace ea"));
}

#[test]
fn test_cpp_generation_return_type() {
    let hpp = ea_compiler::bind_cpp::generate(dot_json(), "kernel").unwrap();

    assert!(hpp.contains("float dot(const float* a, const float* b, int32_t n)"));
    // Span overload
    assert!(hpp.contains("std::span<const float> a"));
    assert!(hpp.contains("std::span<const float> b"));
    assert!(hpp.contains("return dot("));
}

#[test]
fn test_cpp_generation_multiple_functions() {
    let hpp = ea_compiler::bind_cpp::generate(multi_json(), "multi").unwrap();

    assert!(hpp.contains("void add("));
    assert!(hpp.contains("void scale("));
    // Both have span overloads
    assert!(hpp.contains("inline void add("));
    assert!(hpp.contains("inline void scale("));
}

#[test]
fn test_roundtrip_source_to_cpp() {
    let source = r#"
        export func dot(a: *f32, b: *f32, n: i32) -> f32 {
            let mut sum: f32 = 0.0
            let mut i: i32 = 0
            while i < n {
                sum = sum + a[i] * b[i]
                i = i + 1
            }
            return sum
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "dot.so");

    let hpp = ea_compiler::bind_cpp::generate(&json, "dot").unwrap();

    assert!(hpp.contains("namespace ea {"));
    assert!(hpp.contains("std::span<const float>"));
    assert!(hpp.contains("extern \"C\""));
    assert!(hpp.contains(".size()"));
}
