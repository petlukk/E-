// Tests for JSON metadata emission and Python binding generation.

// --- JSON metadata tests (no LLVM needed) ---

#[test]
fn test_json_metadata_exports() {
    let source = r#"
        export func scale(data: *mut f32, len: i32, alpha: f32) {
            let mut i: i32 = 0
            while i < len {
                data[i] = data[i] * alpha
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "scale.so");

    assert!(json.contains("\"library\": \"scale.so\""));
    assert!(json.contains("\"name\": \"scale\""));
    assert!(json.contains("\"name\": \"data\", \"type\": \"*mut f32\""));
    assert!(json.contains("\"name\": \"len\", \"type\": \"i32\""));
    assert!(json.contains("\"name\": \"alpha\", \"type\": \"f32\""));
    assert!(json.contains("\"return_type\": null"));
}

#[test]
fn test_json_metadata_return_type() {
    let source = r#"
        export func dot(a: *f32, b: *f32, n: i32) -> f32 {
            let mut sum: f32 = 0.0
            let mut i: i32 = 0
            while i < n {
                sum = sum + a[i] * b[i]
                i = i + 1
            }
            return sum
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "dot.so");

    assert!(json.contains("\"name\": \"dot\""));
    assert!(json.contains("\"return_type\": \"f32\""));
}

#[test]
fn test_json_metadata_struct() {
    let source = r#"
        struct Particle {
            x: f32,
            y: f32,
        }

        export func update(p: *mut Particle, n: i32) {
            let mut i: i32 = 0
            while i < n {
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "particle.so");

    assert!(json.contains("\"name\": \"Particle\""));
    assert!(json.contains("\"name\": \"x\", \"type\": \"f32\""));
    assert!(json.contains("\"name\": \"y\", \"type\": \"f32\""));
    assert!(json.contains("\"name\": \"update\""));
}

#[test]
fn test_json_metadata_multiple_exports() {
    let source = r#"
        export func add(a: *f32, b: *f32, out: *mut f32, n: i32) {
            let mut i: i32 = 0
            while i < n {
                out[i] = a[i] + b[i]
                i = i + 1
            }
        }

        func helper(x: i32) -> i32 {
            return x * 2
        }

        export func scale(data: *mut f32, n: i32, factor: f32) {
            let mut i: i32 = 0
            while i < n {
                data[i] = data[i] * factor
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "math.so");

    assert!(json.contains("\"name\": \"add\""));
    assert!(json.contains("\"name\": \"scale\""));
    // helper is not exported — should not appear
    assert!(!json.contains("\"name\": \"helper\""));
}

#[test]
fn test_json_metadata_restrict_pointer() {
    let source = r#"
        export func copy(src: *restrict f32, dst: *mut f32, n: i32) {
            let mut i: i32 = 0
            while i < n {
                dst[i] = src[i]
                i = i + 1
            }
        }
    "#;
    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "copy.so");

    assert!(json.contains("\"type\": \"*restrict f32\""));
    assert!(json.contains("\"type\": \"*mut f32\""));
}

// --- Python generation tests ---

#[test]
fn test_python_generation_basic() {
    let json = r#"{
  "library": "kernel.so",
  "exports": [
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "alpha", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "kernel").unwrap();

    assert!(py.contains("\"\"\"kernel — generated by ea bind\"\"\""));
    assert!(py.contains("import ctypes as _ct"));
    assert!(py.contains("import numpy as _np"));
    assert!(py.contains("_lib = _ct.CDLL("));
    assert!(py.contains("kernel.so"));
    assert!(py.contains("_lib.scale.argtypes = ["));
    assert!(py.contains("_ct.POINTER(_ct.c_float)"));
    assert!(py.contains("_ct.c_int32"));
    assert!(py.contains("_ct.c_float"));
    assert!(py.contains("_lib.scale.restype = None"));
    // len should be collapsed — not in Python signature
    assert!(py.contains("def scale(data: _np.ndarray, alpha: float):"));
    // dtype check
    assert!(py.contains("if data.dtype != _np.float32:"));
    assert!(py.contains("raise TypeError(\"data: expected float32\")"));
    // Auto-fill len from data.size
    assert!(py.contains("data.size"));
}

#[test]
fn test_python_generation_return_type() {
    let json = r#"{
  "library": "dot.so",
  "exports": [
    {
      "name": "dot",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "n", "type": "i32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "dot").unwrap();

    assert!(py.contains("_lib.dot.restype = _ct.c_float"));
    assert!(py.contains("-> float:"));
    assert!(py.contains("_result = _lib.dot("));
    assert!(py.contains("return float(_result)"));
}

#[test]
fn test_python_generation_no_collapse_without_pointer() {
    let json = r#"{
  "library": "test.so",
  "exports": [
    {
      "name": "compute",
      "args": [{"name": "n", "type": "i32"}, {"name": "x", "type": "f32"}],
      "return_type": "f32"
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "test").unwrap();

    // n should NOT be collapsed (no preceding pointer)
    assert!(py.contains("def compute(n: int, x: float)"));
}

#[test]
fn test_python_generation_multiple_functions() {
    let json = r#"{
  "library": "multi.so",
  "exports": [
    {
      "name": "add",
      "args": [{"name": "a", "type": "*f32"}, {"name": "b", "type": "*f32"}, {"name": "out", "type": "*mut f32"}, {"name": "n", "type": "i32"}],
      "return_type": null
    },
    {
      "name": "scale",
      "args": [{"name": "data", "type": "*mut f32"}, {"name": "len", "type": "i32"}, {"name": "factor", "type": "f32"}],
      "return_type": null
    }
  ],
  "structs": []
}"#;

    let py = ea_compiler::bind_python::generate(json, "multi").unwrap();

    assert!(py.contains("def add("));
    assert!(py.contains("def scale("));
    assert!(py.contains("_lib.add.argtypes"));
    assert!(py.contains("_lib.scale.argtypes"));
}

// --- Round-trip test: source → parse → JSON → Python ---

#[test]
fn test_roundtrip_source_to_python() {
    let source = r#"
        export func fma_kernel(a: *restrict f32, b: *restrict f32, c: *restrict f32, out: *mut f32, len: i32) {
            let mut i: i32 = 0
            while i < len {
                out[i] = a[i] * b[i] + c[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "fma.so");

    let py = ea_compiler::bind_python::generate(&json, "fma").unwrap();

    // Verify structural correctness
    assert!(py.contains("\"\"\"fma — generated by ea bind\"\"\""));
    assert!(py.contains("def fma_kernel("));
    assert!(py.contains("a: _np.ndarray"));
    assert!(py.contains("b: _np.ndarray"));
    assert!(py.contains("c: _np.ndarray"));
    assert!(py.contains("out: _np.ndarray"));
    // len should be collapsed
    assert!(!py.contains("len: int"));
    assert!(py.contains(".size"));
    // dtype checks for all pointer args
    assert!(py.contains("if a.dtype != _np.float32:"));
    assert!(py.contains("if b.dtype != _np.float32:"));
    assert!(py.contains("if c.dtype != _np.float32:"));
    assert!(py.contains("if out.dtype != _np.float32:"));
}

#[test]
fn test_roundtrip_integer_types() {
    let source = r#"
        export func process_bytes(input: *u8, output: *mut u8, count: i32) {
            let mut i: i32 = 0
            while i < count {
                output[i] = input[i]
                i = i + 1
            }
        }
    "#;

    let tokens = ea_compiler::tokenize(source).unwrap();
    let stmts = ea_compiler::parse(tokens).unwrap();
    let json = ea_compiler::metadata::generate_json(&stmts, "bytes.so");

    let py = ea_compiler::bind_python::generate(&json, "bytes").unwrap();

    assert!(py.contains("_ct.POINTER(_ct.c_uint8)"));
    assert!(py.contains("_np.uint8"));
    // count should be collapsed
    assert!(py.contains("def process_bytes(input: _np.ndarray, output: _np.ndarray):"));
}
