# Phase 5: Explicit SIMD — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement SIMD vector types (`f32x4`, `i32x4`) and explicit element-wise operations (`.+`, `.-`, `.*`, `./`, `splat`, `load`, `store`) to enable high-performance kernel writing.

**Architecture:**
- **Lexer**: Adds SIMD type keywords and dotted operators (`.+`).
- **AST**: Adds `SIMDVectorType` and `SIMDExpr`.
- **Type Checker**: Validates vector sizes and element-wise compatibility.
- **Codegen**: Maps to LLVM vector types (`<4 x float>`) and instructions (`fadd`, `fmul`, `insertelement`, `shufflevector`).

**Tech Stack:** Rust, inkwell (LLVM 14), vector intrinsics.

---

## Current State

- **49 passing tests** (Phase 1-4 cover scalars, pointers, recursion).
- **File Sizes**: All files are under 350 lines (Codegen expressions is largest at 326).
- **Architecture**: Clean separation of concerns.

**Files to modify/add** (13 files):

| File | Current Lines | Changes |
|------|--------------|---------|
| `src/lexer/mod.rs` | 221 | +SIMD types, operators |
| `src/lexer/tokens.rs` | 51 | +Display for new tokens |
| `src/ast/mod.rs` | 217 | +SIMD types, Expr variants |
| `src/ast/simd.rs` | NEW | +SIMD structs (keep ast/mod.rs clean) |
| `src/parser/mod.rs` | 202 | +SIMD type parsing |
| `src/parser/expressions.rs` | 202 | +SIMD literals, calls, element access |
| `src/typeck/types.rs` | 109 | +Vector types |
| `src/typeck/check.rs` | 307 | +SIMD validation rules |
| `src/codegen/mod.rs` | 179 | +Vector LLVM types |
| `src/codegen/expressions.rs` | 326 | +Vector math codegen |
| `src/codegen/simd.rs` | NEW | +SIMD helper codegen |
| `tests/phase5.rs` | NEW | ~15 new SIMD tests |

---

### Task 1: Lexer & AST foundation

**Files:**
- Modify: `src/lexer/mod.rs`
- Modify: `src/lexer/tokens.rs`
- Modify: `src/ast/mod.rs`
- Create: `src/ast/simd.rs`

**Step 1: Add SIMD tokens**
- Types: `f32x4`, `i32x4`
- Operators: `.+`, `.-`, `.*`, `./`
- Keywords: `splat` (handled as identifier or keyword?) -> Keyword to avoid shadowing.

**Step 2: Add SIMD AST**
- `TypeAnnotation::Vector(Box<TypeAnnotation>, usize)`
- `Expr::Link` (call to intrinsics like `splat`, `load`, `store`)? Or use `Expr::Call` with special handling?
    - **Decision**: Use `Expr::Call` for `splat/load/store` (treated as builtins).
    - Use `Expr::Binary` with new `Op` variants for `.+`.
    - Use `Expr::Index` (or new `Expr::Extract`) for `vec[i]`. `Expr::Index` is cleaner if we map it correctly.

---

### Task 2: Parser — SIMD syntax

**Files:**
- Modify: `src/parser/mod.rs` (Types)
- Modify: `src/parser/expressions.rs` (Literals, operators)

**Step 1: Parse vector types**
- `parse_type` handles `f32x4`, `i32x4`.

**Step 2: Parse vector literals**
- `[1.0, 2.0, 3.0, 4.0]f32x4` syntax.
- Parse standard array-like syntax `[` exprs `]` followed by type suffix.

**Step 3: Parse dotted operators**
- Update `parse_binary` to recognize `.+` etc. with correct precedence (same as standard math).

**Step 4: Parse element access**
- Re-use `Expr::Index` parsing? Yes, `vec[i]` looks just like array indexing.
- Ensure `primary()` parser handles it (it does, but Type Checker needs valid rules).

---

### Task 3: Type System — Vector Logic

**Files:**
- Modify: `src/typeck/types.rs`
- Modify: `src/typeck/check.rs`

**Step 1: Add Type::Vector**
- `Vector { elem: Box<Type>, width: usize }`

**Step 2: Validate Operations**
- `.+`: LHS and RHS must be same vector type (e.g., both `f32x4`).
- `splat(x)`: `x` must match vector element type.
- `load(ptr, offset)`: `ptr` must be pointer to element type.
- `store(ptr, offset, val)`: `val` must be vector, `ptr` matches element.

---

### Task 4: Codegen — LLVM Vectors

**Files:**
- Modify: `src/codegen/mod.rs`
- Modify: `src/codegen/expressions.rs`
- Create: `src/codegen/simd.rs`

**Step 1: Map types**
- `f32x4` -> `<4 x float>`
- `i32x4` -> `<4 x i32>`

**Step 2: Implement operations**
- `.+` -> `builder.build_float_add` (for vectors)
- `.*` -> `builder.build_float_mul`
- `splat` -> `builder.build_vector_splat`
- `load` -> GEP scalar ptr + load vector (ptr cast approach)
- `store` -> Store vector to ptr (ptr cast approach)
- `reduce_add` -> `builder.build_call` to llvm.vector.reduce.fadd
- `extract(v, i)` -> `builder.build_extract_element`
- `shuffle(v, mask)` -> `builder.build_shuffle_vector`

---

### Task 5: Advanced SIMD (Reductions & Shuffles)

**Files:**
- Modify: `src/codegen/simd.rs`

**Step 1: Reductions**
- `reduce_add(v)`: Sums all elements. Uses `llvm.vector.reduce.fadd` intrinsic.

**Step 2: Element Access**
- `val[i]`: Runtime or compile-time index? LLVM `extractelement` supports runtime index.

**Step 3: Shuffles**
- `shuffle(v, [0, 1, 2, 3])`: Mask must be compile-time constant for `shufflevector`.

---

### Task 6: Verification

**Step 1: Test Suite**
- Create `tests/phase5.rs`
- Test `vector_add` (f32x4)
- Test `splat`
- Test `load` / `store` offsets

---

## Technical Details

**Builtin Intrinsic Signatures:**

```ea
// Generic-ish handling in type checker
splat(val: T) -> TxN
load(ptr: *T, offset: i32) -> TxN
store(ptr: *mut T, offset: i32, val: TxN) -> void
```

**Memory Layout:**
- `f32x4` is 16-byte aligned (usually).
- `load` / `store` unaligned?
    - Spec says `load(ptr, i)`. `i` is element index (offset).
    - `ptr` is `*f32`.
    - Address = `ptr + i * sizeof(f32)`.
    - Effective load: `*(<4 x float>*) (ptr + i)`.

**LLVM IR Strategy:**
```llvm
%ptr_i8 = bitcast float* %src to i8*
%offset_bytes = mul i32 %i, 4
%base_i8 = getelementptr i8, i8* %ptr_i8, i32 %offset_bytes
%vec_ptr = bitcast i8* %base_i8 to <4 x float>*
%val = load <4 x float>, <4 x float>* %vec_ptr, align 4
```
(Or just GEP on float* then bitcast pointer).

---
