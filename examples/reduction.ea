// Multi-accumulator reductions: sum, max, min.
// Two independent dependency chains per loop â†’ ILP on superscalar CPUs.
// Demonstrates: reduce_add, reduce_max, reduce_min, select, multi-acc pattern.

export func sum_f32x8(data: *restrict f32, len: i32) -> f32 {
    let mut acc0: f32x8 = splat(0.0)
    let mut acc1: f32x8 = splat(0.0)
    let mut i: i32 = 0
    while i + 16 <= len {
        let v0: f32x8 = load(data, i)
        let v1: f32x8 = load(data, i + 8)
        acc0 = acc0 .+ v0
        acc1 = acc1 .+ v1
        i = i + 16
    }
    let mut total: f32 = reduce_add(acc0 .+ acc1)
    while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

export func max_f32x4(data: *restrict f32, len: i32) -> f32 {
    let mut acc0: f32x4 = load(data, 0)
    let mut acc1: f32x4 = load(data, 0)
    let mut i: i32 = 4
    while i + 8 <= len {
        let v0: f32x4 = load(data, i)
        let v1: f32x4 = load(data, i + 4)
        acc0 = select(acc0 .> v0, acc0, v0)
        acc1 = select(acc1 .> v1, acc1, v1)
        i = i + 8
    }
    let mut acc: f32x4 = select(acc0 .> acc1, acc0, acc1)
    while i + 4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .> v, acc, v)
        i = i + 4
    }
    let mut result: f32 = reduce_max(acc)
    while i < len {
        if data[i] > result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}

export func min_f32x4(data: *restrict f32, len: i32) -> f32 {
    let mut acc0: f32x4 = load(data, 0)
    let mut acc1: f32x4 = load(data, 0)
    let mut i: i32 = 4
    while i + 8 <= len {
        let v0: f32x4 = load(data, i)
        let v1: f32x4 = load(data, i + 4)
        acc0 = select(acc0 .< v0, acc0, v0)
        acc1 = select(acc1 .< v1, acc1, v1)
        i = i + 8
    }
    let mut acc: f32x4 = select(acc0 .< acc1, acc0, acc1)
    while i + 4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .< v, acc, v)
        i = i + 4
    }
    let mut result: f32 = reduce_min(acc)
    while i < len {
        if data[i] < result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}
