// Horizontal Reduction Benchmark: Sum, Max, Min across arrays
// Compute-bound: reduction operations dominate, not memory bandwidth

const LANE_4: i32 = 4
const LANE_8: i32 = 8

static_assert(LANE_8 % LANE_4 == 0, "LANE_8 must be multiple of LANE_4")

export func sum_f32x4(data: *restrict f32, len: i32) -> f32 {
    let mut acc: f32x4 = splat(0.0)
    let mut i: i32 = 0
    while i + LANE_4 <= len {
        let v: f32x4 = load(data, i)
        acc = acc .+ v
        i = i + LANE_4
    }
    let mut total: f32 = reduce_add(acc)
    while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

export func sum_f32x8(data: *restrict f32, len: i32) -> f32 {
    let mut acc: f32x8 = splat(0.0)
    let mut i: i32 = 0
    while i + LANE_8 <= len {
        let v: f32x8 = load(data, i)
        acc = acc .+ v
        i = i + LANE_8
    }
    let mut total: f32 = reduce_add(acc)
    while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

// Multi-accumulator: 2 independent dependency chains → ILP on superscalar CPUs.
// LLVM 18 does not auto-unroll reduction loops; express parallelism explicitly.
export func max_f32x4(data: *restrict f32, len: i32) -> f32 {
    let mut acc0: f32x4 = load(data, 0)
    let mut acc1: f32x4 = load(data, 0)
    let mut i: i32 = LANE_4
    while i + LANE_8 <= len {
        let v0: f32x4 = load(data, i)
        let v1: f32x4 = load(data, i + LANE_4)
        acc0 = select(acc0 .> v0, acc0, v0)
        acc1 = select(acc1 .> v1, acc1, v1)
        i = i + LANE_8
    }
    let mut acc: f32x4 = select(acc0 .> acc1, acc0, acc1)
    while i + LANE_4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .> v, acc, v)
        i = i + LANE_4
    }
    let mut result: f32 = reduce_max(acc)
    while i < len {
        if data[i] > result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}

// foreach scalar sum (relies on LLVM auto-vectorization)
export func sum_foreach(data: *restrict f32, len: i32) -> f32 {
    let mut total: f32 = 0.0
    foreach (i in 0..len) {
        total = total + data[i]
    }
    return total
}

// unroll(4) while — single accumulator with hint
export func sum_unroll(data: *restrict f32, len: i32) -> f32 {
    let mut total: f32 = 0.0
    let mut i: i32 = 0
    unroll(4) while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

// Multi-accumulator min reduction
export func min_f32x4(data: *restrict f32, len: i32) -> f32 {
    let mut acc0: f32x4 = load(data, 0)
    let mut acc1: f32x4 = load(data, 0)
    let mut i: i32 = LANE_4
    while i + LANE_8 <= len {
        let v0: f32x4 = load(data, i)
        let v1: f32x4 = load(data, i + LANE_4)
        acc0 = select(acc0 .< v0, acc0, v0)
        acc1 = select(acc1 .< v1, acc1, v1)
        i = i + LANE_8
    }
    let mut acc: f32x4 = select(acc0 .< acc1, acc0, acc1)
    while i + LANE_4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .< v, acc, v)
        i = i + LANE_4
    }
    let mut result: f32 = reduce_min(acc)
    while i < len {
        if data[i] < result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}
