// Horizontal Reduction Benchmark: Sum, Max, Min across arrays
// Compute-bound: reduction operations dominate, not memory bandwidth

export func sum_f32x4(data: *f32, len: i32) -> f32 {
    let mut acc: f32x4 = splat(0.0)
    let mut i: i32 = 0
    while i + 4 <= len {
        let v: f32x4 = load(data, i)
        acc = acc .+ v
        i = i + 4
    }
    let mut total: f32 = reduce_add(acc)
    while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

export func sum_f32x8(data: *f32, len: i32) -> f32 {
    let mut acc: f32x8 = splat(0.0)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(data, i)
        acc = acc .+ v
        i = i + 8
    }
    let mut total: f32 = reduce_add(acc)
    while i < len {
        total = total + data[i]
        i = i + 1
    }
    return total
}

export func max_f32x4(data: *f32, len: i32) -> f32 {
    let mut acc: f32x4 = load(data, 0)
    let mut i: i32 = 4
    while i + 4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .> v, acc, v)
        i = i + 4
    }
    let mut result: f32 = reduce_max(acc)
    while i < len {
        if data[i] > result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}

export func min_f32x4(data: *f32, len: i32) -> f32 {
    let mut acc: f32x4 = load(data, 0)
    let mut i: i32 = 4
    while i + 4 <= len {
        let v: f32x4 = load(data, i)
        acc = select(acc .< v, acc, v)
        i = i + 4
    }
    let mut result: f32 = reduce_min(acc)
    while i < len {
        if data[i] < result {
            result = data[i]
        }
        i = i + 1
    }
    return result
}
