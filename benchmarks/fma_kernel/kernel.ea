// FMA Kernel: Fused Multiply-Add benchmark
// Computes: result[i] = a[i] * b[i] + c[i]
// Explicit SIMD widths: f32x4 (128-bit) and f32x8 (256-bit)


// ============================================================
// f32x4 version (128-bit SIMD)
// ============================================================

export func fma_kernel_f32x4(
    a: *restrict f32,
    b: *restrict f32, 
    c: *restrict f32,
    result: *restrict mut f32,
    len: i32
) {
    let mut i: i32 = 0
    
    // Process 4 elements at a time
    while i + 4 <= len {
        let va: f32x4 = load(a, i)
        let vb: f32x4 = load(b, i)
        let vc: f32x4 = load(c, i)
        
        // Fused multiply-add
        let vresult: f32x4 = fma(va, vb, vc)
        
        store(result, i, vresult)
        i = i + 4
    }
    
    // Scalar remainder
    while i < len {
        result[i] = a[i] * b[i] + c[i]
        i = i + 1
    }
}


// ============================================================
// f32x8 version (256-bit SIMD)
// ============================================================

export func fma_kernel_f32x8(
    a: *restrict f32,
    b: *restrict f32, 
    c: *restrict f32,
    result: *restrict mut f32,
    len: i32
) {
    let mut i: i32 = 0
    
    // Process 8 elements at a time
    while i + 8 <= len {
        let va: f32x8 = load(a, i)
        let vb: f32x8 = load(b, i)
        let vc: f32x8 = load(c, i)
        
        // Fused multiply-add
        let vresult: f32x8 = fma(va, vb, vc)
        
        store(result, i, vresult)
        i = i + 8
    }
    
    // Scalar remainder
    while i < len {
        result[i] = a[i] * b[i] + c[i]
        i = i + 1
    }
}
