// Fused MNIST preprocessing: normalize + standardize + clip in ONE pass.
// Input: f32 pixel values [0, 255] (pre-cast from u8 by Python).
// Output: f32 normalized, standardized, clipped to [0, 1].
//
// Fuses what NumPy does in 4-5 separate memory passes:
//   x = x / 255.0          (normalize)
//   x = (x - mean) / std   (standardize)
//   x = clip(x, 0, 1)      (clip)
//
// All in register. No intermediate arrays. One read, one write.

export func preprocess_fused(
    input: *restrict f32,
    out: *mut f32,
    len: i32,
    scale: f32,
    mean: f32,
    inv_std: f32
) {
    let vscale: f32x8 = splat(scale)
    let vmean: f32x8 = splat(mean)
    let vinv_std: f32x8 = splat(inv_std)
    let vzero: f32x8 = splat(0.0)
    let vone: f32x8 = splat(1.0)
    let mut i: i32 = 0
    while i + 8 <= len {
        // normalize: x * (1/255)
        let v: f32x8 = load(input, i)
        let norm: f32x8 = v .* vscale

        // standardize: (norm - mean) * inv_std
        let centered: f32x8 = norm .- vmean
        let scaled: f32x8 = centered .* vinv_std

        // clip to [0, 1]: branchless via select
        let clamped_lo: f32x8 = select(scaled .< vzero, vzero, scaled)
        let clamped: f32x8 = select(clamped_lo .> vone, vone, clamped_lo)

        store(out, i, clamped)
        i = i + 8
    }
    while i < len {
        let norm: f32 = input[i] * scale
        let std_val: f32 = (norm - mean) * inv_std
        let mut result: f32 = std_val
        if result < 0.0 { result = 0.0 }
        if result > 1.0 { result = 1.0 }
        out[i] = result
        i = i + 1
    }
}
