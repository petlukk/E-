// Fusion scaling experiment.
// Same data, increasing number of fused operations.
// NumPy does N passes. Ea does 1 pass. Measure the difference.

// 1 op: scale
export func fused_1(input: *restrict f32, out: *mut f32, len: i32, s1: f32) {
    let vs1: f32x8 = splat(s1)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(input, i)
        store(out, i, v .* vs1)
        i = i + 8
    }
    while i < len {
        out[i] = input[i] * s1
        i = i + 1
    }
}

// 2 ops: scale, subtract
export func fused_2(input: *restrict f32, out: *mut f32, len: i32, s1: f32, s2: f32) {
    let vs1: f32x8 = splat(s1)
    let vs2: f32x8 = splat(s2)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(input, i)
        let a: f32x8 = v .* vs1
        let b: f32x8 = a .- vs2
        store(out, i, b)
        i = i + 8
    }
    while i < len {
        out[i] = input[i] * s1 - s2
        i = i + 1
    }
}

// 4 ops: scale, subtract, multiply, clip_lo
export func fused_4(input: *restrict f32, out: *mut f32, len: i32,
                    s1: f32, s2: f32, s3: f32) {
    let vs1: f32x8 = splat(s1)
    let vs2: f32x8 = splat(s2)
    let vs3: f32x8 = splat(s3)
    let vzero: f32x8 = splat(0.0)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(input, i)
        let a: f32x8 = v .* vs1
        let b: f32x8 = a .- vs2
        let c: f32x8 = b .* vs3
        let d: f32x8 = select(c .< vzero, vzero, c)
        store(out, i, d)
        i = i + 8
    }
    while i < len {
        let r: f32 = (input[i] * s1 - s2) * s3
        if r < 0.0 { out[i] = 0.0 } else { out[i] = r }
        i = i + 1
    }
}

// 6 ops: scale, subtract, multiply, clip_lo, clip_hi, add bias
export func fused_6(input: *restrict f32, out: *mut f32, len: i32,
                    s1: f32, s2: f32, s3: f32, s4: f32) {
    let vs1: f32x8 = splat(s1)
    let vs2: f32x8 = splat(s2)
    let vs3: f32x8 = splat(s3)
    let vs4: f32x8 = splat(s4)
    let vzero: f32x8 = splat(0.0)
    let vone: f32x8 = splat(1.0)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(input, i)
        let a: f32x8 = v .* vs1
        let b: f32x8 = a .- vs2
        let c: f32x8 = b .* vs3
        let d: f32x8 = select(c .< vzero, vzero, c)
        let e: f32x8 = select(d .> vone, vone, d)
        let f: f32x8 = e .+ vs4
        store(out, i, f)
        i = i + 8
    }
    while i < len {
        let r: f32 = (input[i] * s1 - s2) * s3
        let mut v: f32 = r
        if v < 0.0 { v = 0.0 }
        if v > 1.0 { v = 1.0 }
        out[i] = v + s4
        i = i + 1
    }
}

// 8 ops: scale, subtract, multiply, clip_lo, clip_hi, add bias, scale2, clip final
export func fused_8(input: *restrict f32, out: *mut f32, len: i32,
                    s1: f32, s2: f32, s3: f32, s4: f32, s5: f32) {
    let vs1: f32x8 = splat(s1)
    let vs2: f32x8 = splat(s2)
    let vs3: f32x8 = splat(s3)
    let vs4: f32x8 = splat(s4)
    let vs5: f32x8 = splat(s5)
    let vzero: f32x8 = splat(0.0)
    let vone: f32x8 = splat(1.0)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(input, i)
        let a: f32x8 = v .* vs1
        let b: f32x8 = a .- vs2
        let c: f32x8 = b .* vs3
        let d: f32x8 = select(c .< vzero, vzero, c)
        let e: f32x8 = select(d .> vone, vone, d)
        let f: f32x8 = e .+ vs4
        let g: f32x8 = f .* vs5
        let h: f32x8 = select(g .< vzero, vzero, g)
        store(out, i, h)
        i = i + 8
    }
    while i < len {
        let r: f32 = (input[i] * s1 - s2) * s3
        let mut v: f32 = r
        if v < 0.0 { v = 0.0 }
        if v > 1.0 { v = 1.0 }
        v = (v + s4) * s5
        if v < 0.0 { v = 0.0 }
        out[i] = v
        i = i + 1
    }
}
