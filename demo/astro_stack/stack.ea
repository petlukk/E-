// Astronomy frame stacking: accumulate N noisy exposures, then scale.
// Signal reinforces, noise cancels by sqrt(N).
// Two kernels: accumulate (called N times), scale (called once).

// In-place accumulation: acc[i] += frame[i]
export func accumulate_f32x8(acc: *mut f32, frame: *restrict f32, len: i32) {
    let mut i: i32 = 0
    while i + 8 <= len {
        let va: f32x8 = load(acc, i)
        let vf: f32x8 = load(frame, i)
        store(acc, i, va .+ vf)
        i = i + 8
    }
    while i < len {
        acc[i] = acc[i] + frame[i]
        i = i + 1
    }
}

// foreach accumulation variant (relies on LLVM auto-vectorization at O2+)
export func accumulate_foreach(acc: *mut f32, frame: *restrict f32, len: i32) {
    foreach (i in 0..len) {
        acc[i] = acc[i] + frame[i]
    }
}

// Scale: out[i] = data[i] * factor
// Called with factor = 1.0 / N to compute mean.
export func scale_f32x8(data: *restrict f32, out: *mut f32, len: i32, factor: f32) {
    let vfactor: f32x8 = splat(factor)
    let mut i: i32 = 0
    while i + 8 <= len {
        let v: f32x8 = load(data, i)
        store(out, i, v .* vfactor)
        i = i + 8
    }
    while i < len {
        out[i] = data[i] * factor
        i = i + 1
    }
}
