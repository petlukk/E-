// CSV structural parsing kernels for Eastat.
//
// Six exports:
//   extract_positions_quoted  — single-pass structural scan (delims + LFs)
//   build_row_arrays          — compute row start/end from LF positions
//   build_row_delim_index     — per-row delimiter mapping via merge-scan
//   compute_field_bounds      — field start/end for a given column
//   batch_atof                — ASCII-to-float parser
//   field_length_stats        — string column length statistics


// Scan raw text bytes, extract delimiter and newline (LF) positions in one pass.
// Handles CSV quoting: delimiters/newlines inside double-quoted fields are skipped.
//
// out_counts: [delim_count, lf_count, header_delim_count]
// header_delim_count = number of delimiters before the first LF (gives col_count = hdc + 1)
export func extract_positions_quoted(
    text: *u8,
    len: i32,
    delim: u8,
    out_delim_pos: *mut i32,
    out_lf_pos: *mut i32,
    out_counts: *mut i32
) {
    let mut dc: i32 = 0
    let mut lc: i32 = 0
    let mut in_quote: i32 = 0
    let mut header_dc: i32 = -1
    let mut i: i32 = 0

    while i < len {
        let b: u8 = text[i]

        if b == 34 {
            if in_quote == 0 {
                in_quote = 1
            } else {
                in_quote = 0
            }
        }

        if in_quote == 0 {
            if b == delim {
                out_delim_pos[dc] = i
                dc = dc + 1
            }
            if b == 10 {
                if header_dc == -1 {
                    header_dc = dc
                }
                out_lf_pos[lc] = i
                lc = lc + 1
            }
        }

        i = i + 1
    }

    if header_dc == -1 {
        header_dc = dc
    }

    out_counts[0] = dc
    out_counts[1] = lc
    out_counts[2] = header_dc
}


// Compute row_starts/row_ends arrays from LF positions in one pass.
// Replaces ~70 lines of Python edge-case logic for row boundary computation.
//
// header_end: position of the first LF (header boundary), or -1 if no header.
// Handles: header skip, last row without trailing newline, empty file.
export func build_row_arrays(
    lf_pos: *i32,
    n_lfs: i32,
    header_end: i32,
    text_len: i32,
    out_row_starts: *mut i32,
    out_row_ends: *mut i32,
    out_n_rows: *mut i32
) {
    let mut n_rows: i32 = 0

    if header_end >= 0 {
        // Has header: lf_pos[0] is the header LF.
        // Data rows are between consecutive LFs starting from index 0.
        // Row i: starts at lf_pos[i]+1, ends at lf_pos[i+1]
        let mut i: i32 = 0
        while i + 1 < n_lfs {
            out_row_starts[n_rows] = lf_pos[i] + 1
            out_row_ends[n_rows] = lf_pos[i + 1]
            n_rows = n_rows + 1
            i = i + 1
        }
        // Last row without trailing newline
        if n_lfs > 0 {
            let last_lf: i32 = lf_pos[n_lfs - 1]
            if last_lf + 1 < text_len {
                out_row_starts[n_rows] = last_lf + 1
                out_row_ends[n_rows] = text_len
                n_rows = n_rows + 1
            }
        }
    } else {
        // No header: all LFs are data boundaries
        if n_lfs > 0 {
            // First row: byte 0 to first LF
            out_row_starts[n_rows] = 0
            out_row_ends[n_rows] = lf_pos[0]
            n_rows = n_rows + 1

            // Rows between consecutive LFs
            let mut i: i32 = 1
            while i < n_lfs {
                out_row_starts[n_rows] = lf_pos[i - 1] + 1
                out_row_ends[n_rows] = lf_pos[i]
                n_rows = n_rows + 1
                i = i + 1
            }

            // Last row without trailing newline
            let last_lf: i32 = lf_pos[n_lfs - 1]
            if last_lf + 1 < text_len {
                out_row_starts[n_rows] = last_lf + 1
                out_row_ends[n_rows] = text_len
                n_rows = n_rows + 1
            }
        } else {
            // No LFs at all: entire file is one row (if non-empty)
            if text_len > 0 {
                out_row_starts[n_rows] = 0
                out_row_ends[n_rows] = text_len
                n_rows = n_rows + 1
            }
        }
    }

    out_n_rows[0] = n_rows
}


// Build per-row delimiter index via merge-scan of sorted arrays.
// Given sorted delim_pos[] and sorted row_ends[], compute:
//   delims_per_row[i]:    number of delimiters in row i
//   row_delim_offset[i]:  index into delim_pos where row i's delimiters start
//
// O(n_delims + n_rows) merge — replaces searchsorted + bincount.
export func build_row_delim_index(
    delim_pos: *i32,
    n_delims: i32,
    row_ends: *i32,
    n_rows: i32,
    out_delims_per_row: *mut i32,
    out_row_delim_offset: *mut i32
) {
    let mut di: i32 = 0
    let mut ri: i32 = 0

    while ri < n_rows {
        out_row_delim_offset[ri] = di
        let row_end: i32 = row_ends[ri]
        let mut count: i32 = 0

        let mut scanning: i32 = 1
        while di < n_delims && scanning == 1 {
            if delim_pos[di] < row_end {
                count = count + 1
                di = di + 1
            } else {
                scanning = 0
            }
        }

        out_delims_per_row[ri] = count
        ri = ri + 1
    }
}


// Compute field start/end positions for a specific column across all rows.
// Given structural index, outputs field_starts[i] and field_ends[i] for each row.
export func compute_field_bounds(
    col_idx: i32,
    col_count: i32,
    n_rows: i32,
    row_starts: *i32,
    row_ends: *i32,
    delim_pos: *i32,
    row_delim_offset: *i32,
    delims_per_row: *i32,
    out_field_starts: *mut i32,
    out_field_ends: *mut i32
) {
    let mut i: i32 = 0
    let last_col: i32 = col_count - 1

    while i < n_rows {
        let rs: i32 = row_starts[i]
        let re: i32 = row_ends[i]
        let ndel: i32 = delims_per_row[i]
        let off: i32 = row_delim_offset[i]

        if col_idx == 0 {
            out_field_starts[i] = rs
            if ndel > 0 {
                out_field_ends[i] = delim_pos[off]
            } else {
                out_field_ends[i] = re
            }
        } else {
            if col_idx >= last_col {
                out_field_ends[i] = re
                if ndel >= col_idx {
                    out_field_starts[i] = delim_pos[off + col_idx - 1] + 1
                } else {
                    out_field_starts[i] = re
                }
            } else {
                if ndel > col_idx {
                    out_field_starts[i] = delim_pos[off + col_idx - 1] + 1
                    out_field_ends[i] = delim_pos[off + col_idx]
                } else {
                    if ndel == col_idx {
                        out_field_starts[i] = delim_pos[off + col_idx - 1] + 1
                        out_field_ends[i] = re
                    } else {
                        out_field_starts[i] = re
                        out_field_ends[i] = re
                    }
                }
            }
        }

        i = i + 1
    }
}


// Parse n numeric fields from raw byte data into f32 values.
// Handles: integers, decimals, signed values, leading whitespace, quotes.
// Skips nulls (empty fields, non-numeric text). Returns valid count via out_count.
//
// ASCII: '0'=48 '9'=57 '-'=45 '+'=43 '.'=46 ' '=32 '\t'=9 '\r'=13 '"'=34
export func batch_atof(
    data: *u8,
    starts: *i32,
    ends: *i32,
    n: i32,
    out: *mut f32,
    out_count: *mut i32
) {
    let mut count: i32 = 0
    let mut i: i32 = 0

    while i < n {
        let mut pos: i32 = starts[i]
        let end: i32 = ends[i]

        if pos < end {
            // Skip leading whitespace, quotes, CR
            let mut trimming: i32 = 1
            while pos < end && trimming == 1 {
                let b: u8 = data[pos]
                if b == 32 || b == 9 || b == 13 || b == 34 {
                    pos = pos + 1
                } else {
                    trimming = 0
                }
            }

            // Skip trailing whitespace, quotes, CR
            let mut trim_end: i32 = end
            let mut trimming_end: i32 = 1
            while trim_end > pos && trimming_end == 1 {
                let b: u8 = data[trim_end - 1]
                if b == 32 || b == 9 || b == 13 || b == 34 {
                    trim_end = trim_end - 1
                } else {
                    trimming_end = 0
                }
            }

            if pos < trim_end {
                let first: u8 = data[pos]

                let mut is_numeric: i32 = 0
                if first >= 48 && first <= 57 {
                    is_numeric = 1
                }
                if first == 45 || first == 43 {
                    is_numeric = 1
                }
                if first == 46 {
                    is_numeric = 1
                }

                if is_numeric == 1 {
                    let mut negative: i32 = 0
                    if first == 45 {
                        negative = 1
                        pos = pos + 1
                    } else {
                        if first == 43 {
                            pos = pos + 1
                        }
                    }

                    let mut int_part: f32 = 0.0
                    let mut has_digits: i32 = 0
                    let mut parsing_int: i32 = 1
                    while pos < trim_end && parsing_int == 1 {
                        let b: u8 = data[pos]
                        if b >= 48 && b <= 57 {
                            int_part = int_part * 10.0 + to_f32(to_i32(b) - 48)
                            has_digits = 1
                            pos = pos + 1
                        } else {
                            parsing_int = 0
                        }
                    }

                    let mut frac: f32 = 0.0
                    let mut frac_scale: f32 = 0.1
                    if pos < trim_end {
                        let dot_check: u8 = data[pos]
                        if dot_check == 46 {
                            pos = pos + 1
                            let mut parsing_frac: i32 = 1
                            while pos < trim_end && parsing_frac == 1 {
                                let b: u8 = data[pos]
                                if b >= 48 && b <= 57 {
                                    frac = frac + to_f32(to_i32(b) - 48) * frac_scale
                                    frac_scale = frac_scale * 0.1
                                    has_digits = 1
                                    pos = pos + 1
                                } else {
                                    parsing_frac = 0
                                }
                            }
                        }
                    }

                    if has_digits == 1 {
                        let mut result: f32 = int_part + frac
                        if negative == 1 {
                            result = 0.0 - result
                        }
                        out[count] = result
                        count = count + 1
                    }
                }
            }
        }

        i = i + 1
    }

    out_count[0] = count
}


// Compute field length statistics for string columns.
// Returns min/max/total length and null count.
export func field_length_stats(
    starts: *i32,
    ends: *i32,
    n: i32,
    out_min_len: *mut i32,
    out_max_len: *mut i32,
    out_total_len: *mut i32,
    out_null_count: *mut i32
) {
    let mut min_len: i32 = 2147483647
    let mut max_len: i32 = 0
    let mut total_len: i32 = 0
    let mut null_count: i32 = 0
    let mut valid_count: i32 = 0
    let mut i: i32 = 0

    while i < n {
        let len: i32 = ends[i] - starts[i]
        if len <= 0 {
            null_count = null_count + 1
        } else {
            total_len = total_len + len
            valid_count = valid_count + 1
            if len < min_len {
                min_len = len
            }
            if len > max_len {
                max_len = len
            }
        }
        i = i + 1
    }

    if valid_count == 0 {
        min_len = 0
    }

    out_min_len[0] = min_len
    out_max_len[0] = max_len
    out_total_len[0] = total_len
    out_null_count[0] = null_count
}
