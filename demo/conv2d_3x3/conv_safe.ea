// 3x3 depthwise-separable-style int8 convolution, NHWC layout — safe i32 accumulator variant
// src:  (H+2) x (W+2) x C_in  — padded input, uint8
// wt:   9 x C_in              — 3x3 kernel weights, int8
// dst:  H x W                 — one output channel, int32
// C_in must be a multiple of 32
// Uses maddubs_i32 (pmaddubsw+pmaddwd) — immune to accumulator overflow.
export func conv2d_3x3_u8i8_safe(src: *u8, wt: *i8, dst: *mut i32, H: i32, W: i32, C_in: i32) {
    let stride: i32 = (W + 2) * C_in
    let mut row: i32 = 0
    while row < H {
        let mut col: i32 = 0
        while col < W {
            let mut acc0: i32x4 = splat(0)
            let mut acc1: i32x4 = splat(0)
            let mut dr: i32 = 0
            while dr < 3 {
                let mut dc: i32 = 0
                while dc < 3 {
                    let src_off: i32 = (row + dr) * stride + (col + dc) * C_in
                    let wt_off: i32 = (dr * 3 + dc) * C_in
                    let mut ci: i32 = 0
                    while ci < C_in {
                        let a0: u8x16 = load(src, src_off + ci)
                        let b0: i8x16 = load(wt, wt_off + ci)
                        acc0 = acc0 .+ maddubs_i32(a0, b0)
                        let a1: u8x16 = load(src, src_off + ci + 16)
                        let b1: i8x16 = load(wt, wt_off + ci + 16)
                        acc1 = acc1 .+ maddubs_i32(a1, b1)
                        ci = ci + 32
                    }
                    dc = dc + 1
                }
                dr = dr + 1
            }
            let s: i32 = reduce_add(acc0) + reduce_add(acc1)
            dst[row * W + col] = s
            col = col + 1
        }
        row = row + 1
    }
}
