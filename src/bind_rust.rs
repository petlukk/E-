use crate::bind_common::{
    find_collapsed_args, is_mut_pointer, parse_exports, parse_string_field, pointer_inner,
    ExportFunc,
};

pub fn generate(json_str: &str, module_stem: &str) -> Result<String, String> {
    let exports = parse_exports(json_str)?;
    let lib_name = parse_string_field(json_str, "library")
        .map(|l| {
            l.trim_end_matches(".so")
                .trim_end_matches(".dll")
                .to_string()
        })
        .unwrap_or_else(|| module_stem.to_string());

    let mut out = String::new();
    out.push_str(&format!("//! {module_stem} â€” generated by ea bind\n\n"));

    // FFI module with raw extern "C" signatures
    out.push_str(&format!("#[link(name = \"{lib_name}\")]\n"));
    out.push_str("mod ffi {\n");
    out.push_str("    extern \"C\" {\n");
    for func in &exports {
        emit_ffi_decl(&mut out, func);
    }
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Safe wrapper functions
    for (i, func) in exports.iter().enumerate() {
        emit_safe_wrapper(&mut out, func);
        if i + 1 < exports.len() {
            out.push('\n');
        }
    }

    Ok(out)
}

fn emit_ffi_decl(out: &mut String, func: &ExportFunc) {
    let params: Vec<String> = func
        .args
        .iter()
        .map(|a| format!("{}: {}", a.name, rust_ffi_type(&a.ty)))
        .collect();
    let ret = match &func.return_type {
        Some(ty) => format!(" -> {}", rust_ffi_type(ty)),
        None => String::new(),
    };
    out.push_str(&format!(
        "        pub fn {}({}){ret};\n",
        func.name,
        params.join(", ")
    ));
}

fn emit_safe_wrapper(out: &mut String, func: &ExportFunc) {
    let collapsed = find_collapsed_args(&func.args);

    // Build doc comment showing original C signature
    let c_args: Vec<String> = func
        .args
        .iter()
        .map(|a| format!("{}: {}", a.name, a.ty))
        .collect();
    let c_ret = func.return_type.as_deref().unwrap_or("void");
    out.push_str(&format!(
        "/// {}({}) -> {}\n",
        func.name,
        c_args.join(", "),
        c_ret
    ));

    // Build safe parameter list
    let mut safe_params = Vec::new();
    for (i, arg) in func.args.iter().enumerate() {
        if collapsed[i] {
            continue;
        }
        safe_params.push(format!("{}: {}", arg.name, rust_safe_type(&arg.ty)));
    }

    let ret = match &func.return_type {
        Some(ty) => format!(" -> {}", rust_ffi_type(ty)),
        None => String::new(),
    };

    out.push_str(&format!(
        "pub fn {}({}){ret} {{\n",
        func.name,
        safe_params.join(", ")
    ));
    out.push_str("    unsafe {\n");

    // Build call arguments
    let mut call_args = Vec::new();
    let mut last_ptr_arg: Option<&str> = None;
    for (i, arg) in func.args.iter().enumerate() {
        if pointer_inner(&arg.ty).is_some() {
            last_ptr_arg = Some(&arg.name);
        }
        if collapsed[i] {
            let ptr_name = last_ptr_arg.unwrap_or("data");
            call_args.push(format!("{ptr_name}.len() as {}", rust_ffi_type(&arg.ty)));
        } else if pointer_inner(&arg.ty).is_some() {
            if is_mut_pointer(&arg.ty) {
                call_args.push(format!("{}.as_mut_ptr()", arg.name));
            } else {
                call_args.push(format!("{}.as_ptr()", arg.name));
            }
        } else {
            call_args.push(arg.name.clone());
        }
    }

    out.push_str(&format!("        ffi::{}(\n", func.name));
    for (i, ca) in call_args.iter().enumerate() {
        out.push_str(&format!("            {ca}"));
        if i + 1 < call_args.len() {
            out.push(',');
        }
        out.push('\n');
    }
    out.push_str("        )\n");
    out.push_str("    }\n");
    out.push_str("}\n");
}

fn rust_ffi_type(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        let inner_ty = rust_scalar_type(inner);
        if is_mut_pointer(ty) {
            format!("*mut {inner_ty}")
        } else {
            format!("*const {inner_ty}")
        }
    } else {
        rust_scalar_type(ty)
    }
}

fn rust_safe_type(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        let inner_ty = rust_scalar_type(inner);
        if is_mut_pointer(ty) {
            format!("&mut [{inner_ty}]")
        } else {
            format!("&[{inner_ty}]")
        }
    } else {
        rust_scalar_type(ty)
    }
}

fn rust_scalar_type(ty: &str) -> String {
    match ty {
        "i8" | "u8" | "i16" | "u16" | "i32" | "u32" | "i64" | "u64" | "f32" | "f64" | "bool" => {
            ty.to_string()
        }
        other => format!("i32 /* unknown: {other} */"),
    }
}
