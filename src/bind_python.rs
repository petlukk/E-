use crate::bind_common::{
    find_collapsed_args, has_out_params, parse_exports, parse_string_field, pointer_inner,
    ExportFunc,
};

pub fn generate(json_str: &str, module_stem: &str) -> Result<String, String> {
    let exports = parse_exports(json_str)?;
    let lib_name =
        parse_string_field(json_str, "library").unwrap_or_else(|| format!("{module_stem}.so"));

    let mut out = String::new();
    out.push_str(&format!(
        "\"\"\"{module_stem} â€” generated by ea bind\"\"\"\n"
    ));
    out.push_str("import ctypes as _ct\n");
    out.push_str("import numpy as _np\n");
    out.push_str("from pathlib import Path as _Path\n\n");
    out.push_str(&format!(
        "_lib = _ct.CDLL(str(_Path(__file__).with_name(\"{lib_name}\")))\n\n"
    ));

    for func in &exports {
        emit_argtypes(&mut out, func);
        emit_restype(&mut out, func);
        out.push('\n');
        emit_wrapper(&mut out, func);
        out.push('\n');
    }

    Ok(out)
}

fn emit_argtypes(out: &mut String, func: &ExportFunc) {
    out.push_str(&format!("_lib.{}.argtypes = [", func.name));
    for (i, arg) in func.args.iter().enumerate() {
        if i > 0 {
            out.push_str(", ");
        }
        out.push_str(&ctype_for(&arg.ty));
    }
    out.push_str("]\n");
}

fn emit_restype(out: &mut String, func: &ExportFunc) {
    match &func.return_type {
        Some(ty) => out.push_str(&format!("_lib.{}.restype = {}\n", func.name, ctype_for(ty))),
        None => out.push_str(&format!("_lib.{}.restype = None\n", func.name)),
    }
}

fn emit_wrapper(out: &mut String, func: &ExportFunc) {
    let collapsed = find_collapsed_args(&func.args);
    let use_out = has_out_params(func);

    // Collect out params with cap (auto-allocated, hidden from signature)
    let auto_out: Vec<&crate::bind_common::Arg> = func
        .args
        .iter()
        .filter(|a| a.direction == "out" && a.cap.is_some())
        .collect();

    let mut py_params = Vec::new();
    for (i, arg) in func.args.iter().enumerate() {
        if collapsed[i] {
            continue;
        }
        // Hide auto-allocated out params from signature
        if arg.direction == "out" && arg.cap.is_some() {
            continue;
        }
        let annotation = python_annotation(&arg.ty);
        py_params.push(format!("{}: {}", arg.name, annotation));
    }

    // Determine return annotation
    let ret_annotation = if !auto_out.is_empty() {
        if auto_out.len() == 1 {
            " -> _np.ndarray".to_string()
        } else {
            let types: Vec<&str> = auto_out.iter().map(|_| "_np.ndarray").collect();
            format!(" -> tuple[{}]", types.join(", "))
        }
    } else if let Some(ty) = &func.return_type {
        format!(" -> {}", python_return_annotation(ty))
    } else {
        String::new()
    };

    out.push_str(&format!(
        "def {}({}){ret_annotation}:\n",
        func.name,
        py_params.join(", ")
    ));

    let c_args: Vec<String> = func
        .args
        .iter()
        .map(|a| format!("{}: {}", a.name, a.ty))
        .collect();
    let c_ret = func.return_type.as_deref().unwrap_or("void");
    out.push_str(&format!(
        "    \"\"\"{}({}) -> {}\"\"\"\n",
        func.name,
        c_args.join(", "),
        c_ret
    ));

    // Dtype checks for non-auto-allocated pointer args
    for arg in &func.args {
        if arg.direction == "out" && arg.cap.is_some() {
            continue;
        }
        if let Some(inner) = pointer_inner(&arg.ty) {
            if let Some(dtype) = numpy_dtype(inner) {
                out.push_str(&format!("    if {}.dtype != _np.{dtype}:\n", arg.name));
                out.push_str(&format!(
                    "        raise TypeError(\"{}: expected {dtype}\")\n",
                    arg.name
                ));
            }
        }
    }

    // Auto-allocate out buffers
    for arg in &auto_out {
        if let Some(inner) = pointer_inner(&arg.ty) {
            let cap = arg.cap.as_deref().unwrap();
            let dtype = numpy_dtype(inner).unwrap_or("float32");
            out.push_str(&format!(
                "    {} = _np.empty({}, dtype=_np.{dtype})\n",
                arg.name, cap
            ));
        }
    }

    // Build call arguments
    let mut call_args = Vec::new();
    let mut last_ptr_arg: Option<&str> = None;
    for (i, arg) in func.args.iter().enumerate() {
        if pointer_inner(&arg.ty).is_some() {
            last_ptr_arg = Some(&arg.name);
        }
        if collapsed[i] {
            let ptr_name = last_ptr_arg.unwrap_or("data");
            call_args.push(format!("        {}({}.size)", ctype_for(&arg.ty), ptr_name));
        } else if pointer_inner(&arg.ty).is_some() {
            call_args.push(format!(
                "        {}.ctypes.data_as({})",
                arg.name,
                ctype_for(&arg.ty)
            ));
        } else {
            call_args.push(format!(
                "        {}({}({}))",
                ctype_for(&arg.ty),
                python_cast(&arg.ty),
                arg.name
            ));
        }
    }

    if func.return_type.is_some() && !use_out {
        out.push_str(&format!("    _result = _lib.{}(\n", func.name));
    } else {
        out.push_str(&format!("    _lib.{}(\n", func.name));
    }
    for (i, ca) in call_args.iter().enumerate() {
        out.push_str(ca);
        if i + 1 < call_args.len() {
            out.push(',');
        }
        out.push('\n');
    }
    out.push_str("    )\n");

    // Return
    if !auto_out.is_empty() {
        if auto_out.len() == 1 {
            out.push_str(&format!("    return {}\n", auto_out[0].name));
        } else {
            let names: Vec<&str> = auto_out.iter().map(|a| a.name.as_str()).collect();
            out.push_str(&format!("    return {}\n", names.join(", ")));
        }
    } else if let Some(ty) = &func.return_type {
        out.push_str(&format!("    return {}(_result)\n", python_return_cast(ty)));
    }
}

fn ctype_for(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        return format!("_ct.POINTER({})", scalar_ctype(inner));
    }
    scalar_ctype(ty)
}

fn scalar_ctype(ty: &str) -> String {
    match ty {
        "i8" => "_ct.c_int8".into(),
        "u8" => "_ct.c_uint8".into(),
        "i16" => "_ct.c_int16".into(),
        "u16" => "_ct.c_uint16".into(),
        "i32" => "_ct.c_int32".into(),
        "u32" => "_ct.c_uint32".into(),
        "i64" => "_ct.c_int64".into(),
        "u64" => "_ct.c_uint64".into(),
        "f32" => "_ct.c_float".into(),
        "f64" => "_ct.c_double".into(),
        "bool" => "_ct.c_bool".into(),
        other => format!("_ct.c_int32 /* unknown: {other} */"),
    }
}

fn numpy_dtype(ty: &str) -> Option<&'static str> {
    match ty {
        "i8" => Some("int8"),
        "u8" => Some("uint8"),
        "i16" => Some("int16"),
        "u16" => Some("uint16"),
        "i32" => Some("int32"),
        "u32" => Some("uint32"),
        "i64" => Some("int64"),
        "u64" => Some("uint64"),
        "f32" => Some("float32"),
        "f64" => Some("float64"),
        _ => None,
    }
}

fn python_annotation(ty: &str) -> &'static str {
    if pointer_inner(ty).is_some() {
        return "_np.ndarray";
    }
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_return_annotation(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_cast(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_return_cast(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}
