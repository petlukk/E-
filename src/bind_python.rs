pub fn generate(json_str: &str, module_stem: &str) -> Result<String, String> {
    let exports = parse_exports(json_str)?;
    let lib_name =
        parse_string_field(json_str, "library").unwrap_or_else(|| format!("{module_stem}.so"));

    let mut out = String::new();
    out.push_str(&format!(
        "\"\"\"{module_stem} â€” generated by ea bind\"\"\"\n"
    ));
    out.push_str("import ctypes as _ct\n");
    out.push_str("import numpy as _np\n");
    out.push_str("from pathlib import Path as _Path\n\n");
    out.push_str(&format!(
        "_lib = _ct.CDLL(str(_Path(__file__).with_name(\"{lib_name}\")))\n\n"
    ));

    for func in &exports {
        emit_argtypes(&mut out, func);
        emit_restype(&mut out, func);
        out.push('\n');
        emit_wrapper(&mut out, func);
        out.push('\n');
    }

    Ok(out)
}

struct ExportFunc {
    name: String,
    args: Vec<Arg>,
    return_type: Option<String>,
}

struct Arg {
    name: String,
    ty: String,
}

fn emit_argtypes(out: &mut String, func: &ExportFunc) {
    out.push_str(&format!("_lib.{}.argtypes = [", func.name));
    for (i, arg) in func.args.iter().enumerate() {
        if i > 0 {
            out.push_str(", ");
        }
        out.push_str(&ctype_for(&arg.ty));
    }
    out.push_str("]\n");
}

fn emit_restype(out: &mut String, func: &ExportFunc) {
    match &func.return_type {
        Some(ty) => out.push_str(&format!("_lib.{}.restype = {}\n", func.name, ctype_for(ty))),
        None => out.push_str(&format!("_lib.{}.restype = None\n", func.name)),
    }
}

fn emit_wrapper(out: &mut String, func: &ExportFunc) {
    // Determine which args are length params (collapsed from Python signature)
    let collapsed = find_collapsed_args(&func.args);

    // Build Python parameter list (skip collapsed length params)
    let mut py_params = Vec::new();
    for (i, arg) in func.args.iter().enumerate() {
        if collapsed[i] {
            continue;
        }
        let annotation = python_annotation(&arg.ty);
        py_params.push(format!("{}: {}", arg.name, annotation));
    }

    let ret_annotation = match &func.return_type {
        Some(ty) => format!(" -> {}", python_return_annotation(ty)),
        None => String::new(),
    };

    out.push_str(&format!(
        "def {}({}){ret_annotation}:\n",
        func.name,
        py_params.join(", ")
    ));

    // Docstring showing original C signature
    let c_args: Vec<String> = func
        .args
        .iter()
        .map(|a| format!("{}: {}", a.name, a.ty))
        .collect();
    let c_ret = func.return_type.as_deref().unwrap_or("void");
    out.push_str(&format!(
        "    \"\"\"{}({}) -> {}\"\"\"\n",
        func.name,
        c_args.join(", "),
        c_ret
    ));

    // Emit dtype checks for pointer args
    for arg in &func.args {
        if let Some(inner) = pointer_inner(&arg.ty) {
            if let Some(dtype) = numpy_dtype(inner) {
                out.push_str(&format!("    if {}.dtype != _np.{dtype}:\n", arg.name));
                out.push_str(&format!(
                    "        raise TypeError(\"{}: expected {dtype}\")\n",
                    arg.name
                ));
            }
        }
    }

    // Build call arguments
    let mut call_args = Vec::new();
    let mut last_ptr_arg: Option<&str> = None;
    for (i, arg) in func.args.iter().enumerate() {
        if let Some(_inner) = pointer_inner(&arg.ty) {
            last_ptr_arg = Some(&arg.name);
        }
        if collapsed[i] {
            // Auto-fill from last pointer's .size
            let ptr_name = last_ptr_arg.unwrap_or("data");
            call_args.push(format!("        {}({}.size)", ctype_for(&arg.ty), ptr_name));
        } else if pointer_inner(&arg.ty).is_some() {
            call_args.push(format!(
                "        {}.ctypes.data_as({})",
                arg.name,
                ctype_for(&arg.ty)
            ));
        } else {
            call_args.push(format!(
                "        {}({}({}))",
                ctype_for(&arg.ty),
                python_cast(&arg.ty),
                arg.name
            ));
        }
    }

    if func.return_type.is_some() {
        out.push_str(&format!("    _result = _lib.{}(\n", func.name));
    } else {
        out.push_str(&format!("    _lib.{}(\n", func.name));
    }
    for (i, ca) in call_args.iter().enumerate() {
        out.push_str(ca);
        if i + 1 < call_args.len() {
            out.push(',');
        }
        out.push('\n');
    }
    out.push_str("    )\n");

    if let Some(ty) = &func.return_type {
        out.push_str(&format!("    return {}(_result)\n", python_return_cast(ty)));
    }
}

fn find_collapsed_args(args: &[Arg]) -> Vec<bool> {
    let length_names = ["n", "len", "length", "count", "size", "num"];
    let mut collapsed = vec![false; args.len()];
    let mut has_preceding_pointer = false;

    for (i, arg) in args.iter().enumerate() {
        if pointer_inner(&arg.ty).is_some() {
            has_preceding_pointer = true;
        } else if has_preceding_pointer
            && is_integer_type(&arg.ty)
            && length_names.contains(&arg.name.as_str())
        {
            collapsed[i] = true;
        }
    }
    collapsed
}

fn is_integer_type(ty: &str) -> bool {
    matches!(ty, "i32" | "i64" | "u32" | "u64")
}

fn pointer_inner(ty: &str) -> Option<&str> {
    let ty = ty.trim();
    if let Some(rest) = ty.strip_prefix("*mut ") {
        Some(rest.trim())
    } else if let Some(rest) = ty.strip_prefix("*restrict mut ") {
        Some(rest.trim())
    } else if let Some(rest) = ty.strip_prefix("*restrict ") {
        Some(rest.trim())
    } else if let Some(rest) = ty.strip_prefix('*') {
        Some(rest.trim())
    } else {
        None
    }
}

fn ctype_for(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        return format!("_ct.POINTER({})", scalar_ctype(inner));
    }
    scalar_ctype(ty)
}

fn scalar_ctype(ty: &str) -> String {
    match ty {
        "i8" => "_ct.c_int8".into(),
        "u8" => "_ct.c_uint8".into(),
        "i16" => "_ct.c_int16".into(),
        "u16" => "_ct.c_uint16".into(),
        "i32" => "_ct.c_int32".into(),
        "u32" => "_ct.c_uint32".into(),
        "i64" => "_ct.c_int64".into(),
        "u64" => "_ct.c_uint64".into(),
        "f32" => "_ct.c_float".into(),
        "f64" => "_ct.c_double".into(),
        "bool" => "_ct.c_bool".into(),
        other => format!("_ct.c_int32 /* unknown: {other} */"),
    }
}

fn numpy_dtype(ty: &str) -> Option<&'static str> {
    match ty {
        "i8" => Some("int8"),
        "u8" => Some("uint8"),
        "i16" => Some("int16"),
        "u16" => Some("uint16"),
        "i32" => Some("int32"),
        "u32" => Some("uint32"),
        "i64" => Some("int64"),
        "u64" => Some("uint64"),
        "f32" => Some("float32"),
        "f64" => Some("float64"),
        _ => None,
    }
}

fn python_annotation(ty: &str) -> &'static str {
    if pointer_inner(ty).is_some() {
        return "_np.ndarray";
    }
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_return_annotation(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_cast(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

fn python_return_cast(ty: &str) -> &'static str {
    match ty {
        "f32" | "f64" => "float",
        "bool" => "bool",
        _ => "int",
    }
}

// --- Minimal JSON parsing (no serde) ---

fn parse_exports(json: &str) -> Result<Vec<ExportFunc>, String> {
    let exports_start = json
        .find("\"exports\"")
        .ok_or("missing \"exports\" in JSON")?;
    let after_key = &json[exports_start + "\"exports\"".len()..];
    let arr_start = after_key.find('[').ok_or("missing '[' after \"exports\"")?;
    let arr_content = &after_key[arr_start..];
    let arr_end = find_matching_bracket(arr_content)?;
    let arr_str = &arr_content[1..arr_end];

    let mut funcs = Vec::new();
    let mut pos = 0;
    while pos < arr_str.len() {
        if let Some(obj_start) = arr_str[pos..].find('{') {
            let obj_slice = &arr_str[pos + obj_start..];
            let obj_end = find_matching_brace(obj_slice)?;
            let obj_str = &obj_slice[..=obj_end];
            funcs.push(parse_export_obj(obj_str)?);
            pos = pos + obj_start + obj_end + 1;
        } else {
            break;
        }
    }
    Ok(funcs)
}

fn parse_export_obj(obj: &str) -> Result<ExportFunc, String> {
    let name = parse_string_field(obj, "name").ok_or("missing \"name\" in export")?;
    let return_type = parse_nullable_string_field(obj, "return_type");

    // Parse args array
    let args_start = obj.find("\"args\"").ok_or("missing \"args\" in export")?;
    let after_key = &obj[args_start + "\"args\"".len()..];
    let arr_start = after_key.find('[').ok_or("missing '[' after \"args\"")?;
    let arr_content = &after_key[arr_start..];
    let arr_end = find_matching_bracket(arr_content)?;
    let arr_str = &arr_content[1..arr_end];

    let mut args = Vec::new();
    let mut pos = 0;
    while pos < arr_str.len() {
        if let Some(obj_start) = arr_str[pos..].find('{') {
            let obj_slice = &arr_str[pos + obj_start..];
            let obj_end = find_matching_brace(obj_slice)?;
            let arg_obj = &obj_slice[..=obj_end];
            let arg_name = parse_string_field(arg_obj, "name").ok_or("missing \"name\" in arg")?;
            let arg_type = parse_string_field(arg_obj, "type").ok_or("missing \"type\" in arg")?;
            args.push(Arg {
                name: arg_name,
                ty: arg_type,
            });
            pos = pos + obj_start + obj_end + 1;
        } else {
            break;
        }
    }

    Ok(ExportFunc {
        name,
        args,
        return_type,
    })
}

fn parse_string_field(json: &str, key: &str) -> Option<String> {
    let pattern = format!("\"{key}\"");
    let key_pos = json.find(&pattern)?;
    let after_key = &json[key_pos + pattern.len()..];
    let colon_pos = after_key.find(':')?;
    let after_colon = after_key[colon_pos + 1..].trim_start();
    if after_colon.starts_with("null") {
        return None;
    }
    if !after_colon.starts_with('"') {
        return None;
    }
    let content = &after_colon[1..];
    let mut end = 0;
    let bytes = content.as_bytes();
    while end < bytes.len() {
        if bytes[end] == b'\\' {
            end += 2;
        } else if bytes[end] == b'"' {
            break;
        } else {
            end += 1;
        }
    }
    Some(content[..end].replace("\\\"", "\"").replace("\\\\", "\\"))
}

fn parse_nullable_string_field(json: &str, key: &str) -> Option<String> {
    let pattern = format!("\"{key}\"");
    let key_pos = json.find(&pattern)?;
    let after_key = &json[key_pos + pattern.len()..];
    let colon_pos = after_key.find(':')?;
    let after_colon = after_key[colon_pos + 1..].trim_start();
    if after_colon.starts_with("null") {
        return None;
    }
    parse_string_field(json, key)
}

fn find_matching_bracket(s: &str) -> Result<usize, String> {
    let mut depth = 0;
    for (i, c) in s.char_indices() {
        match c {
            '[' => depth += 1,
            ']' => {
                depth -= 1;
                if depth == 0 {
                    return Ok(i);
                }
            }
            _ => {}
        }
    }
    Err("unmatched '['".into())
}

fn find_matching_brace(s: &str) -> Result<usize, String> {
    let mut depth = 0;
    for (i, c) in s.char_indices() {
        match c {
            '{' => depth += 1,
            '}' => {
                depth -= 1;
                if depth == 0 {
                    return Ok(i);
                }
            }
            _ => {}
        }
    }
    Err("unmatched '{'".into())
}
