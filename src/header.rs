use crate::ast::{Stmt, TypeAnnotation};

pub fn generate(stmts: &[Stmt], module_name: &str) -> String {
    let guard = module_name.to_uppercase().replace('-', "_");
    let mut out = String::new();

    out.push_str("/* Generated by Ea compiler */\n");
    out.push_str(&format!("#ifndef {guard}_H\n"));
    out.push_str(&format!("#define {guard}_H\n\n"));
    out.push_str("#include <stdint.h>\n\n");

    for stmt in stmts {
        if let Stmt::Struct { name, fields, .. } = stmt {
            out.push_str(&format!("struct {name} {{\n"));
            for f in fields {
                out.push_str(&format!("    {} {};\n", type_to_c(&f.ty), f.name));
            }
            out.push_str("};\n\n");
        }
    }

    for stmt in stmts {
        if let Stmt::Function {
            name,
            params,
            return_type,
            export: true,
            ..
        } = stmt
        {
            let ret = match return_type {
                Some(ty) => type_to_c(ty),
                None => "void".to_string(),
            };
            let param_list: Vec<String> = params
                .iter()
                .map(|p| format!("{} {}", type_to_c(&p.ty), p.name))
                .collect();
            out.push_str(&format!("{ret} {}({});\n", name, param_list.join(", ")));
        }
    }

    out.push_str(&format!("\n#endif /* {guard}_H */\n"));
    out
}

fn type_to_c(ty: &TypeAnnotation) -> String {
    match ty {
        TypeAnnotation::Named(name) => match name.as_str() {
            "i8" => "int8_t".to_string(),
            "u8" => "uint8_t".to_string(),
            "i16" => "int16_t".to_string(),
            "u16" => "uint16_t".to_string(),
            "i32" => "int32_t".to_string(),
            "u32" => "uint32_t".to_string(),
            "i64" => "int64_t".to_string(),
            "u64" => "uint64_t".to_string(),
            "f32" => "float".to_string(),
            "f64" => "double".to_string(),
            "bool" => "_Bool".to_string(),
            other => format!("struct {other}"),
        },
        TypeAnnotation::Pointer { mutable, inner, .. } => {
            let inner_c = type_to_c(inner);
            if *mutable {
                format!("{inner_c}*")
            } else {
                format!("const {inner_c}*")
            }
        }
        TypeAnnotation::Vector { .. } => "/* SIMD */".to_string(),
    }
}
