use crate::bind_common::{
    find_collapsed_args, is_mut_pointer, parse_exports, pointer_inner, ExportFunc,
};

pub fn generate(json_str: &str, module_stem: &str) -> Result<String, String> {
    let exports = parse_exports(json_str)?;

    let mut out = String::new();
    out.push_str(&format!("// {module_stem}.hpp â€” generated by ea bind\n"));
    out.push_str("#pragma once\n");
    out.push_str("#include <cstdint>\n");
    out.push_str("#include <span>\n\n");
    out.push_str("namespace ea {\n\n");

    // Raw extern "C" declarations
    out.push_str("extern \"C\" {\n");
    for func in &exports {
        emit_c_decl(&mut out, func);
    }
    out.push_str("}\n\n");

    // Safe span-based overloads
    for (i, func) in exports.iter().enumerate() {
        if has_pointer_args(func) {
            emit_span_wrapper(&mut out, func);
            if i + 1 < exports.len() {
                out.push('\n');
            }
        }
    }

    out.push_str("} // namespace ea\n");
    Ok(out)
}

fn emit_c_decl(out: &mut String, func: &ExportFunc) {
    let params: Vec<String> = func
        .args
        .iter()
        .map(|a| format!("{} {}", cpp_raw_type(&a.ty), a.name))
        .collect();
    let ret = match &func.return_type {
        Some(ty) => cpp_raw_type(ty),
        None => "void".to_string(),
    };
    out.push_str(&format!("{ret} {}({});\n", func.name, params.join(", ")));
}

fn emit_span_wrapper(out: &mut String, func: &ExportFunc) {
    let collapsed = find_collapsed_args(&func.args);
    let auto_out: Vec<&crate::bind_common::Arg> = func
        .args
        .iter()
        .filter(|a| a.direction == "out" && a.cap.is_some())
        .collect();

    // Build safe parameter list (exclude auto-allocated out params)
    let mut safe_params = Vec::new();
    for (i, arg) in func.args.iter().enumerate() {
        if collapsed[i] {
            continue;
        }
        if arg.direction == "out" && arg.cap.is_some() {
            continue;
        }
        safe_params.push(format!("{} {}", cpp_span_type(&arg.ty), arg.name));
    }

    // Determine return type
    let ret = if !auto_out.is_empty() {
        if auto_out.len() == 1 {
            let inner = pointer_inner(&auto_out[0].ty).unwrap_or("f32");
            format!("std::vector<{}>", cpp_scalar_type(inner))
        } else {
            let types: Vec<String> = auto_out
                .iter()
                .map(|a| {
                    let inner = pointer_inner(&a.ty).unwrap_or("f32");
                    format!("std::vector<{}>", cpp_scalar_type(inner))
                })
                .collect();
            format!("std::tuple<{}>", types.join(", "))
        }
    } else {
        match &func.return_type {
            Some(ty) => cpp_raw_type(ty),
            None => "void".to_string(),
        }
    };

    out.push_str(&format!(
        "inline {ret} {}({}) {{\n",
        func.name,
        safe_params.join(", ")
    ));

    // Auto-allocate out buffers
    for arg in &auto_out {
        let inner = pointer_inner(&arg.ty).unwrap_or("f32");
        let cap = arg.cap.as_deref().unwrap();
        out.push_str(&format!(
            "    std::vector<{}> {}({cap});\n",
            cpp_scalar_type(inner),
            arg.name
        ));
    }

    // Build call arguments
    let mut call_args = Vec::new();
    let mut last_ptr_arg: Option<&str> = None;
    for (i, arg) in func.args.iter().enumerate() {
        if pointer_inner(&arg.ty).is_some() {
            last_ptr_arg = Some(&arg.name);
        }
        if collapsed[i] {
            let ptr_name = last_ptr_arg.unwrap_or("data");
            call_args.push(format!(
                "static_cast<{}>({ptr_name}.size())",
                cpp_raw_type(&arg.ty)
            ));
        } else if pointer_inner(&arg.ty).is_some() {
            call_args.push(format!("{}.data()", arg.name));
        } else {
            call_args.push(arg.name.clone());
        }
    }

    if !auto_out.is_empty() {
        // Call then return auto-allocated buffers
        out.push_str(&format!("    {}({});\n", func.name, call_args.join(", ")));
        if auto_out.len() == 1 {
            out.push_str(&format!("    return {};\n", auto_out[0].name));
        } else {
            let names: Vec<&str> = auto_out.iter().map(|a| a.name.as_str()).collect();
            out.push_str(&format!(
                "    return std::make_tuple({});\n",
                names.join(", ")
            ));
        }
    } else if func.return_type.is_some() {
        out.push_str(&format!(
            "    return {}({});\n",
            func.name,
            call_args.join(", ")
        ));
    } else {
        out.push_str(&format!("    {}({});\n", func.name, call_args.join(", ")));
    }
    out.push_str("}\n");
}

fn has_pointer_args(func: &ExportFunc) -> bool {
    func.args.iter().any(|a| pointer_inner(&a.ty).is_some())
}

fn cpp_raw_type(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        let inner_c = cpp_scalar_type(inner);
        if is_mut_pointer(ty) {
            format!("{inner_c}*")
        } else {
            format!("const {inner_c}*")
        }
    } else {
        cpp_scalar_type(ty)
    }
}

fn cpp_span_type(ty: &str) -> String {
    if let Some(inner) = pointer_inner(ty) {
        let inner_c = cpp_scalar_type(inner);
        if is_mut_pointer(ty) {
            format!("std::span<{inner_c}>")
        } else {
            format!("std::span<const {inner_c}>")
        }
    } else {
        cpp_scalar_type(ty)
    }
}

fn cpp_scalar_type(ty: &str) -> String {
    match ty {
        "i8" => "int8_t".into(),
        "u8" => "uint8_t".into(),
        "i16" => "int16_t".into(),
        "u16" => "uint16_t".into(),
        "i32" => "int32_t".into(),
        "u32" => "uint32_t".into(),
        "i64" => "int64_t".into(),
        "u64" => "uint64_t".into(),
        "f32" => "float".into(),
        "f64" => "double".into(),
        "bool" => "bool".into(),
        other => format!("int32_t /* unknown: {other} */"),
    }
}
